---
tags: [Book/Effective Java/Ch5 - 제네릭]
title: '[Item 29] 이왕이면 제네릭 타입으로 만들라'
created: '2022-05-10T13:29:01.056Z'
modified: '2022-05-10T15:12:02.201Z'
---

# [Item 29] 이왕이면 제네릭 타입으로 만들라

JDK에서 제공하는 제네릭 타입과 메서드를 사용하는 것은 쉬운 일이지만, 타입을 고려해 제네릭을 만드는 것에는 신경쓸 일이 많다.

## 제네릭 타입으로 만들 때의 문제점

만약 `Object` 클래스로 배열을 만들어 구현한 스택이 있다고 생각해보자. 이 스택을 사용하는 클라이언트는 스택에서 꺼낸 객체를 형변환해서 사용해야 하고, 이 과정에서 런타임 오류가 날 수 있다. **일반적으로 우리가 코드를 제네릭하게 변경하려고 한다면 아래와 같이 실체화 불가능한 제네릭 타입을 실체화하려 시도하다 오류를 만드는 경우가 많다.** `E`와 같은 실체화 불가 타입으로는 배열을 만들 수 없으므로 이러한 문제가 발생한다.

```java
private E[] elements;

elements = new E[DEFAULT_INITIAL_CAPACITY];
```

## 문제를 우회하는 방법

### Object 배열을 생성해 제네릭으로 형변환

배열을 제네릭하게 다루기 위해 시도할 수 있는 첫번째 방법은 Object 배열을 생성해 E 타입으로 형변환해 대입하는 것이다. 다만 컴파일러가 `unchecked cast` 경고를 내보낼 수 있다. 프로그래머는 이 비검사 형변환이 프로그램의 타입 안전성을 해치지 않는지 증명하고, `@SuppressWarnings`로 경고를 숨기면 된다. 앞선 장에서 봤듯이 이 어노테이션은 의도치 않았던 경고도 없앨 수 있으므로 최소한의 범위에 달아주어야 한다.

타입 안전성을 해치지 않는지 검사하는 방법
- 배열이 `private` 필드에 저장되는가?
- 배열 요소가 클라이언트에 반환되는가?
- 배열 요소가 다른 메서드에 전달되는가?

```java
@SuppressWarnings("unchecked")
public Stack() {
  private E[] elements;
  elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}
```

### 배열 필드 타입을 Object로 변경한다.

elements 필드의 타입을 `Object[]`로 변경하는 방법을 사용할수도 있다. 그러나 이 경우에도 E는 실체화 불가 타입이므로 런타입 형변환이 안전한지 판단할 방법이 없기 때문에 위 방법대로 안전한 타입 변환인지를 증명해야 한다. 비검사 형변환을 수행하는 모든 할당문에서 `@SuppressWarning`을 명시해줘야 하므로 생성자에만 표시하는 첫번째 방법보다 가독성이 떨어지나, **배열의 런타임 타입이 컴파일타임 타입과 다를 때 발생하는 힙 오염을 방지할 수 있다.**












