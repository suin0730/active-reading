---
tags: [Book/Unit Testing]
title: 목과 테스트 취약성
created: '2022-04-13T23:09:57.299Z'
modified: '2022-04-14T02:51:24.541Z'
---

# 5. 목과 테스트 취약성

## 5.1 목과 스텁 구분

테스트에서 목을 사용하는 것이 항상 좋은 것은 아니다. 목은 테스트에 사용할 수 있는 훌륭한 도구이지만 테스트 리팩터링 내성을 약하게 한다.

### 5.1.1 목과 스텁 구분

테스트 대역은 크게 목과 스텁으로 나눌 수 있고, 상세하게는 다섯 가지 종류로 나눌 수 있다.
- 목: 외부로 나가는 상호작용을 모방, 검사
  - 목: 목 프레임워크의 도움을 받아 만들어진 목
  - 스파이: 수동으로 작성한 목
- 스텁: 내부로 들어오는 상호작용을 모방
  - 스텁: 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 갖춘 의존성
  - 더미: 널값, 가짜 문자열과 같이 단순하고 하드코딩된 값
  - 페이크: 스텁과 유사하지만, 페이크는 보통 아직 존재하지 않는 의존성을 대체하고자 구현

> Mock이라는 용어는 큰 범주를 포함하기 때문에 도구로서의 목(라이브러리)과 테스트 대역으로서의 목을 구분해야 한다.

### 5.1.2 스텁과의 상호작용을 검증하지 말라

스텁은 내부로 들어오는 상호 작용을 모방한다. 리팩터링 내성을 지키기 위해서는 스텁과의 상호작용을 검증하지 않아야 한다. 구현 세부 사항이 아니라 최종 결과를 검증해야 한다. 메서드 실행 결과가 올바르다면 SUT가 최종 결과를 어떻게 생성하는지는 중요하지 않다. **최종 결과뿐 아니라 중간 과정도 검증하는 것을 과잉 명세라 한다.** 과잉 명세는 상호작용을 검사할 때 가장 흔하게 발생한다.

### 5.1.3 목과 스텁은 명령과 조회에 어떻게 관련되는가?

목과 스텁은 명령 조회 분리(Command Query Separation) 원칙과 관련이 있다. 이 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하고, 둘을 혼용하면 안된다. 명령은 객체 상태 변경, 파일 변경 등 side effect를 일으키고 조회는 부작용 없이 값을 반환한다. 다른 말로는 side effect를 일으키는 메서드는 void 반환형을 가져야 한다는 의미이다. 또한 부작용이 없는 조회 메서드는 항상 같은 값을 반환해야 한다. 이렇게 목과 스텁을 구현하면 코드를 읽기 쉽고 세부 구현에 대해 자세히 설명하지 않아도 된다.

## 5.2 식별할 수 있는 동작과 구현 세부 사항

왜 목이 테스트 취약성을 높인다고 하는 것일까?

4장에서 본 바로는 코드의 구현 세부 사항과 테스트가 결합되어 있을 때 거짓 양성이 나타났다. 이러한 결합을 피하려면 구현 사항과 테스트를 가능한 한 떨어뜨려야 하고 '어떻게'가 아닌 '무엇'을 테스트할지에 집중해야 한다.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다

클라이언트가 목표를 달성하는 데에 도움이 되는 operation과 state만 노출하라. 이때 operation은 계산을 수행하고나 side effect를 만들고, state는 시스템의 현재 상태이다. 구현 세부 사항은 두 가지 중 아무것도 하지 않으므로 공개하지 않아야 한다.

### 5.2.2 잘 설계된 API와 캡슐화

잘 설계된 API를 유지보수할 때 캡슐화의 장점을 볼 수 있다. 구현 세부 사항을 노출하면 코드의 복잡성 때문에 캡슐화를 지키지 못하게 된다. 코드가 복잡해질수록 작업하기 어려워지고 프로그래머는 실수할 가능성이 높아진다. 따라서 소프트웨어 프로젝트가 지속적으로 성장하려면 캡슐화가 중요하다.

## 5.3 목과 테스트 취약성 간의 관계

### 5.3.1 육각형 아키텍처 정의

전형적인 어플리케이션은 도메인(비즈니스 로직)과 어플리케이션 서비스라는 두 계층으로 구분된다. 어플리케이션 서비스는 도메인 계층 위에서 외부와의 통신을 조정한다.(데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스를 구체화하거나, 결과를 데이터베이스에 저장하는 등) 육각형 아키텍처는 세가지 중요한 지침을 강조한다.

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
- 애플리케이션 내부 통신은 외부에서 격리되어야 함
- 애플리케이션 간 통신은 공통 인터페이스를 통해 연결되어야 함

### 5.3.2 시스템 내부 통신과 시스템 간 통신

시스템 내부 통신은 구현 세부 사항이므로 클라이언트의 목표와 직접적인 관계가 없으므로 이러한 협력과 테스트가 결합하면 테스트가 취약해진다. 시스템 외부 통신은 별도 애플리케이션과 함께 성장한다. 주요 원칙은 하위 호환성을 지켜야 한다는 것이다.

> 목을 사용하면 시스템과 외부 애플리케이션 간 통신 패턴을 확인할 때 좋지만, 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며 리팩토링 내성 지표가 미흡해진다.

## 5.4 단위 테스트와 고전파 런던파 재고

런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하고 시스템 내 통신과 시스템 외부 통신을 구분하지 않는다. 목을 무분별하게 사용하면 종종 구현 세부 사항과 결합되어 테스트에 리팩터링 내성이 없게 된다.

반면 고전파는 테스트 간에 공유하는 의존성만 교체하므로 문제를 대처하기 용이하다.

### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다

아래는 의존성 유형이다.
- 공유 의존성: 테스트 간에 공유하는 의존성
- 프로세스 외부 의존성: 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성
- 비공개 의존성: 공유하지 않는 모든 의존성

공유 의존성이 프로세스 내부에 있다면 각 테스트 실행 시 의존성을 새 인스턴스로 써서 재사용을 피하고, 프로세스 외부에 있다면 테스트가 더 복잡해진다. 이렇게하면 각 테스트 실행 전에 데이터베이스를 인스턴스화하는 등 준비할 수 없다. 따라서 일반적으로는 의존성을 목과 스텁으로 교체한다.

~

### 5.4.2 목을 사용한 동작 검증

클래스 간 통신은 두뇌의 뉴런이 서로 통과하는 신호를 측정해 사람의 행동을 유추하는 것과 유사하다. 이러한 세부 수준은 세밀하지만 클라이언트에게 중요한 사항은 아니다. **목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 부작용이 외부 환경에서 보일 때만 동작과 관련이 있다.**














